//***********************************************************
//! @file
//! @brief		バイトオーダー
//! @author		Gajumaru
//***********************************************************
#pragma once
#include <Framework/Core/CorePrivate.h>

namespace ob::core {

	//@―---------------------------------------------------------------------------
	//! @brief		バイト順オーダー
	//! 
	//! @details	メモリ上のエンディアンはCPUの種類によって既定される。
	//!				0x1234ABCDという4バイトのデータがあるとき、バイト毎に上位側から「12 34 AB CD」のように並べる順序はビッグエンディアン、
	//!				下位側から「CD AB 34 12」のように並べる順序はリトルエンディアンである。
	//@―---------------------------------------------------------------------------
	enum class ByteOrder :u32 {
		Auto,			//!< 自動判定
		LittleEndian,	//!< リトルエンディアン
		BigEndian,		//!< ビッグエンディアン
	};


	//@―---------------------------------------------------------------------------
	//! @brief		エンディアン・ユーティリティ
	//@―---------------------------------------------------------------------------
	class Endian {
	public:

		//@―---------------------------------------------------------------------------
		//! @brief		現在のシステムがリトルエンディアン
		//@―---------------------------------------------------------------------------
		static inline ByteOrder Get()
		{
			return Endian::IsBigEndian() ? ByteOrder::BigEndian : ByteOrder::LittleEndian;
		}

		//@―---------------------------------------------------------------------------
		//! @brief		現在のシステムがリトルエンディアン
		//@―---------------------------------------------------------------------------
		static inline bool IsLittleEndian()
		{
			int const t = 1;
			return *reinterpret_cast<unsigned char const*>(&t) == 1;
		}

		//@―---------------------------------------------------------------------------
		//! @brief		現在のシステムがビッグエンディアン
		//@―---------------------------------------------------------------------------
		static inline bool IsBigEndian()
		{
			return !IsLittleEndian();
		}

		//@―---------------------------------------------------------------------------
		//! @brief		値のバイト順序を入れ替える
		//@―---------------------------------------------------------------------------
		template<typename T,typename std::enable_if_t<std::is_arithmetic_v<T>>>
		static constexpr T Swap(T value) {
			StaticArray<byte, sizeof(T)> bytes;
			reinterpret_cast<T*>(bytes.data()) = value;
			std::reverse(bytes.begin(), bytes.end());
			return *static_cast<T*>(bytes.data())
		}

	};


}