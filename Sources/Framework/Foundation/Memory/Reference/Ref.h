/*
//***********************************************************
//! @file
//! @brief		参照カウント式スマートポインタ
//! @author		Gajumaru
//***********************************************************
#pragma once
#include "RefObject.h"


namespace ob::foundation {

    //@―---------------------------------------------------------------------------
    //! @brief  参照カウント式スマートポインタ
    //@―---------------------------------------------------------------------------
    template<class T>
    class Ref {
        template<class T, class... TArgs>
        friend Ref<T> MakeRef(TArgs&&... args);

        static_assert(is_base_of_v<RefObject, T>, "T must inherit RefObject");
    public:

        //@―---------------------------------------------------------------------------
        //! @brief  コンストラクタ
        //@―---------------------------------------------------------------------------
        constexpr Ref()noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  コンストラクタ(参照なし)
        //@―---------------------------------------------------------------------------
        constexpr Ref(std::nullptr_t)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  コンストラクタ(生ポインタ指定)
        //@―---------------------------------------------------------------------------
        Ref(T* ptr);


        //@―---------------------------------------------------------------------------
        //! @brief  コピーコンストラクタ
        //@―---------------------------------------------------------------------------
        Ref(const Ref& ref)noexcept;

        //@―---------------------------------------------------------------------------
        //! @brief  コピーコンストラクタ
        //! 
        //! @details 継承関係にあるオブジェクトのコピーに使用される。
        //@―---------------------------------------------------------------------------
        template<class U>
        Ref(const Ref<U>& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブコンストラクタ
        //@―---------------------------------------------------------------------------
        Ref(Ref&& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブコンストラクタ
        //! 
        //! @details 継承関係にあるオブジェクトのムーブに使用される。
        //@―---------------------------------------------------------------------------
        template<class U>
        Ref(Ref<U>&& ref)noexcept;

        //@―---------------------------------------------------------------------------
        //! @brief  デストラクタ
        //@―---------------------------------------------------------------------------
        ~Ref();


        //@―---------------------------------------------------------------------------
        //! @brief  コピー代入演算子
        //@―---------------------------------------------------------------------------
        Ref& operator=(const Ref& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  コピー代入演算子
        //! 
        //! @details 継承関係にあるオブジェクトのコピーに使用される。
        //@―---------------------------------------------------------------------------
        template<class U, enable_if_t<is_base_of_v<T, U>>>
        Ref& operator=(const Ref<U>& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブ代入演算子
        //@―---------------------------------------------------------------------------
        Ref& operator=(Ref&& f)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブ代入演算子
        //! 
        //! @details 継承関係にあるオブジェクトのムーブに使用される。
        //@―---------------------------------------------------------------------------
        template<class U, enable_if_t<is_base_of_v<T, U>>>
        Ref& operator=(Ref<U>&& f)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  インスタンス参照
        //@―---------------------------------------------------------------------------
        T& operator*() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  メンバアクセス
        //@―---------------------------------------------------------------------------
        T* operator->() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  参照先が有効か
        //! 
        //! @retval true    有効
        //! @retval false   無効
        //@―---------------------------------------------------------------------------
        explicit operator bool()const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  インスタンスキャスト
        //@―---------------------------------------------------------------------------
        operator T* () const;


        //@―---------------------------------------------------------------------------
        //! @brief  新しいオブジェクトの所有権を設定する
        //! 
        //! @details    既に保持しているオブジェクトの参照を放棄した後、新しオブジェクト
        //!             を保持する。
        //! @param ptr  新しく保持するオブジェクトのポインタ
        //@―---------------------------------------------------------------------------
        void reset(T* ptr);


        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトの参照を放棄する
        //@―---------------------------------------------------------------------------
        void reset();


        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトのポインタを取得する
        //@―---------------------------------------------------------------------------
        T* get()const;


    private:

        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトの参照を追加する
        //@―---------------------------------------------------------------------------
        void safeRetain();


        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトの参照を放棄する
        //@―---------------------------------------------------------------------------
        void safeRelease();


    private:

        RefObject* m_ptr;

        template<class U>
        friend class Ref;

    };


    //@―---------------------------------------------------------------------------
    //! @brief  get の構築
    //! 
    //! @details    型 T のコンストラクタに args を渡して新しい get を構築します。
    //! @param args コンストラクタに渡す引数
    //@―---------------------------------------------------------------------------
    template<class T, class... TArgs>
    inline Ref<T> MakeRef(TArgs&&... args) {
        return Ref<T>(new T(std::forward<TArgs>(args)...));
    }







    //===============================================================
    // 比較演算子
    //===============================================================

    //@―---------------------------------------------------------------------------
    //! @brief  等価演算子
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator==(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.get() == rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator==(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.get() == nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator==(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr == rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  否等価演算子
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator!=(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.get() != rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  否等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator!=(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.get() != nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  否等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator!=(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr != rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator<(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.get() < rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return std::less<RefObject*>()(lhs.get(), nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return std::less<T*>()(nullptr, rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<=
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator<=(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.get() <= rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<=(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.get() <= nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<=(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr <= rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator>(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.get() > rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.get() > nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr > rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>=
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator>=(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.get() >= rhs.get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>=(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.get() >= nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>=(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr >= rhs.get());
    }





    //===============================================================
    // インライン関数
    //===============================================================
    //! @cond


    //@―---------------------------------------------------------------------------
    //! @brief  コンストラクタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline constexpr Ref<T>::Ref()noexcept
        :m_ptr(nullptr) {

    }


    //@―---------------------------------------------------------------------------
    //! @brief  コンストラクタ(参照なし)
    //@―---------------------------------------------------------------------------
    template<class T>
    inline constexpr Ref<T>::Ref(std::nullptr_t)noexcept
        :m_ptr(nullptr) {

    }


    //@―---------------------------------------------------------------------------
    //! @brief  コンストラクタ(生ポインタ指定)
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::Ref(T* ptr)
        :m_ptr(ptr) {
        safeRetain();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  コピーコンストラクタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::Ref(const Ref& ref)noexcept {
        m_ptr = ref.m_ptr;
        safeRetain();
    }

    //@―---------------------------------------------------------------------------
    //! @brief  コピーコンストラクタ
    //! 
    //! @details 継承関係にあるオブジェクトのコピーに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U>
    inline Ref<T>::Ref(const Ref<U>& ref)noexcept {
        static_assert(is_base_of_v<T, U>, "U must inherit T.");
        m_ptr = ref.m_ptr;
        safeRetain();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブコンストラクタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::Ref(Ref&& ref)noexcept {
        m_ptr = ref.m_ptr;
        ref.m_ptr = nullptr;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブコンストラクタ
    //! 
    //! @details 継承関係にあるオブジェクトのムーブに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U>
    inline Ref<T>::Ref(Ref<U>&& ref)noexcept {
        static_assert(is_base_of_v<T, U>, "U must inherit T.");
        m_ptr = ref.m_ptr;
        ref.m_ptr = nullptr;
    }

    //@―---------------------------------------------------------------------------
    //! @brief  デストラクタ
    template<class T>
    //@―---------------------------------------------------------------------------
    inline Ref<T>::~Ref() {
        safeRelease();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  コピー代入演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>& Ref<T>::operator=(const Ref& ref)noexcept {
        if (m_ptr != ref.m_ptr) {
            if (ref.m_ptr) {
                ref.m_ptr->retain();
            }
            if (m_ptr) {
                m_ptr->release();
            }
            m_ptr = ref.m_ptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  コピー代入演算子
    //! 
    //! @details 継承関係にあるオブジェクトのコピーに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U, typename enable_if_t<is_base_of_v<T, U>>>
    inline Ref<T>& Ref<T>::operator=(const Ref<U>& ref)noexcept {
        if (m_ptr != ref.m_ptr) {
            if (ref.m_ptr) {
                ref.m_ptr->retain();
            }
            if (m_ptr) {
                m_ptr->release();
            }
            m_ptr = ref.m_ptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブ代入演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>& Ref<T>::operator=(Ref&& f)noexcept {
        if (&f != this) {
            safeRelease();
            m_ptr = f.m_ptr;
            f.m_ptr = nullptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブ代入演算子
    //! 
    //! @details 継承関係にあるオブジェクトのムーブに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U, typename enable_if_t<is_base_of_v<T, U>>>
    inline Ref<T>& Ref<T>::operator=(Ref<U>&& f)noexcept {
        if (&f != this) {
            safeRelease();
            m_ptr = f.m_ptr;
            f.m_ptr = nullptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  インスタンス参照
    //@―---------------------------------------------------------------------------
    template<class T>
    inline T& Ref<T>::operator*() const noexcept {
        assert(m_ptr != nullptr);
        return *static_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  メンバアクセス
    //@―---------------------------------------------------------------------------
    template<class T>
    inline T* Ref<T>::operator->() const noexcept {
        assert(m_ptr != nullptr);
        return static_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  参照先が有効か
    //! 
    //! @retval true    有効
    //! @retval false   無効
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::operator bool()const noexcept {
        return m_ptr != nullptr;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  インスタンスキャスト
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::operator T* () const {
        return static_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  新しいオブジェクトの所有権を設定する
    //! 
    //! @details    既に保持しているオブジェクトの参照を放棄した後、新しオブジェクト
    //!             を保持する。
    //! @param ptr  新しく保持するオブジェクトのポインタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::reset(T* ptr) {
        if (ptr != m_ptr) {
            safeRelease();
            m_ptr = ptr;
            safeRetain();
        }
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトの参照を放棄する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::reset() {
        safeRelease();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトのポインタを取得する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline T* Ref<T>::get()const {
        return reinterpret_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトの参照を追加する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::safeRetain() {
        if (m_ptr) {
            m_ptr->retain();
        }
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトの参照を放棄する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::safeRelease() {
        if (m_ptr) {
            m_ptr->release();
            m_ptr = nullptr;
        }
    }

    //! @endcond
}// namespcae ob
*/