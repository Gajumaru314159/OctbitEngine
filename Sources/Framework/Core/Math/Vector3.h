//***********************************************************
//! @file
//! @brief 三次元ベクトル
//! @author Gajumaru
//***********************************************************
#pragma once
#include <Framework/Core/Math/Math.h>

namespace ob::core {

    //@―---------------------------------------------------------------------------
    //! @brief 三次元ベクトル
    //@―---------------------------------------------------------------------------
    struct OB_API Vec3 {
    public:

        //===============================================================
        //  コンストラクタ / デストラクタ
        //===============================================================

        //@―---------------------------------------------------------------------------
        //! @brief      デフォルトコンストラクタ(初期化なし)
        //@―---------------------------------------------------------------------------
        Vec3()noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      コンストラクタ(ゼロ初期化)
        //@―---------------------------------------------------------------------------
        explicit Vec3(EForceInit)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      コンストラクタ(すべての要素を同じ値で初期化)
        //@―---------------------------------------------------------------------------
        explicit Vec3(f32 scalar)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      コンストラクタ(要素を指定して初期化)
        //@―---------------------------------------------------------------------------
        Vec3(f32 x, f32 y, f32 z)noexcept;


        //===============================================================
        //  オペレータ
        //===============================================================

        //@―---------------------------------------------------------------------------
        //! @brief      等価演算子 
        //! 
        //! @details    2つのベクトルの差が Math::TOLERANCE より小さい場合、2つのベクトルは等しいと
        //!             見なされます。
        //@―---------------------------------------------------------------------------
        bool operator == (const Vec3& v) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 否等価演算子
        //! 
        //! @details    2つのベクトルの差が Math::TOLERANCE より大きい場合、2つのベクトルは異なると
        //!             見なされます。
        //@―---------------------------------------------------------------------------
        bool operator != (const Vec3& v) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 加算演算子
        //@―---------------------------------------------------------------------------
        Vec3 operator + (const Vec3& v) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 加算演算子(スカラー)
        //@―---------------------------------------------------------------------------
        Vec3 operator + (f32 scalar) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 減算演算子
        //@―---------------------------------------------------------------------------
        Vec3 operator - (const Vec3& v) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 減算演算子(スカラー)
        //@―---------------------------------------------------------------------------
        Vec3 operator - (f32 scalar) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 乗算演算子
        //@―---------------------------------------------------------------------------
        Vec3 operator * (const Vec3& v) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 乗算演算子(スカラー)
        //@―---------------------------------------------------------------------------
        Vec3 operator * (f32 scalar) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 除算演算子
        //@―---------------------------------------------------------------------------
        Vec3 operator / (const Vec3& v) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 除算演算子(スカラー)
        //@―---------------------------------------------------------------------------
        Vec3 operator / (f32 scalar) const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 加算代入演算子
        //@―---------------------------------------------------------------------------
        Vec3& operator += (const Vec3& v) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 加算代入演算子(スカラー)
        //@―---------------------------------------------------------------------------
        Vec3& operator += (f32 scalar) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 減算代入演算子 
        //@―---------------------------------------------------------------------------
        Vec3& operator -= (const Vec3& v) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 減算代入演算子(スカラー)
        //@―---------------------------------------------------------------------------
        Vec3& operator -= (f32 scalar) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 乗算代入演算子 
        //@―---------------------------------------------------------------------------
        Vec3& operator *= (const Vec3& v) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 乗算代入演算子 (スカラー)
        //@―---------------------------------------------------------------------------
        Vec3& operator *= (f32 scalar) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 除算代入演算子 
        //@―---------------------------------------------------------------------------
        Vec3& operator /= (const Vec3& v) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 除算代入演算子(スカラー)
        //@―---------------------------------------------------------------------------
        Vec3& operator /= (f32 scalar) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 単項マイナス演算子
        //@―---------------------------------------------------------------------------
        Vec3 operator - () const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief f32*Vec3演算子 
        //@―---------------------------------------------------------------------------
        friend Vec3 operator * (f32 scalar, const Vec3& v) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief f32/Vec3演算子 
        //@―---------------------------------------------------------------------------
        friend Vec3 operator / (f32 scalar, const Vec3& v) noexcept;


        //===============================================================
        //  セッター
        //===============================================================

        //@―---------------------------------------------------------------------------
        //! @brief 要素を設定
        //@―---------------------------------------------------------------------------
        void    set(f32 x, f32 y, f32 z) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 要素を設定
        //@―---------------------------------------------------------------------------
        void    set(const Vec3& v) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 要素を全て0に設定
        //@―---------------------------------------------------------------------------
        void    setZero() noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 全ての要素を同じ値で設定
        //@―---------------------------------------------------------------------------
        void    setAll(f32 scalar) noexcept;


        //===============================================================
        //  ゲッター
        //===============================================================

        //@―---------------------------------------------------------------------------
        //! @brief 要素の最大を取得
        //@―---------------------------------------------------------------------------
        f32     maxComponent() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 要素の絶対値の最大を取得
        //@―---------------------------------------------------------------------------
        f32     maxAbsComponent() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 要素の最小を取得
        //@―---------------------------------------------------------------------------
        f32     minComponent() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 要素の絶対値の最小を取得
        //@―---------------------------------------------------------------------------
        f32     minAbsComponent() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief ベクトルの長さを取得
        //! 
        //! @details 二つのベクトルの長さを比較する場合はSqrMagのほうが高速です。
        //@―---------------------------------------------------------------------------
        f32     length() const;


        //@―---------------------------------------------------------------------------
        //! @brief ベクトルの長さの二乗を取得
        //@―---------------------------------------------------------------------------
        f32     sqrLength() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief              単位ベクトルを取得
        //! 
        //! @details            0ベクトルの場合は0ベクトルを返す。
        //! @param tolerance    ゼロベクトル判定の誤差の許容誤差
        //@―---------------------------------------------------------------------------
        Vec3    unitVec(f32 tolerance = Math::TOLERANCE)const;


        //@―---------------------------------------------------------------------------
        //! @brief              単位ベクトルを取得(ゼロチェックなし)
        //@―---------------------------------------------------------------------------
        Vec3    getUnitVecUnsafe()const;


        //@―---------------------------------------------------------------------------
        //! @brief              方向ベクトルとベクトルの長さを取得
        //! 
        //! @param[out] outDir  方向ベクトルの出力
        //! @param[out] outLen  ベクトルの大きさ
        //@―---------------------------------------------------------------------------
        void    toDirectionAndLength(Vec3& outDir, f32& outLen)const;


        //===========================================================
        //  変換
        //===========================================================

        //@―---------------------------------------------------------------------------
        //! @brief              ベクトルの正規化
        //! 
        //! @details            0ベクトルの場合は何もしない。
        //! @param tolerance    ゼロベクトル判定の誤差の許容誤差
        //@―---------------------------------------------------------------------------
        Vec3& normalize(f32 tolerance = Math::TOLERANCE);


        //@―---------------------------------------------------------------------------
        //! @brief              ベクトルの正規化(ゼロチェックなし)
        //@―---------------------------------------------------------------------------
        Vec3& normalizeUnsafe();


        //@―---------------------------------------------------------------------------
        //! @brief      移動
        //@―---------------------------------------------------------------------------
        Vec3& translate(f32 x, f32 y, f32 z) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      移動
        //@―---------------------------------------------------------------------------
        Vec3& translate(const Vec3& add) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      回転
        //! 
        //! @details    回転順序はZXYです。
        //! @param      eulerAngles 回転量(Degrees)
        //@―---------------------------------------------------------------------------
        Vec3& rotate(const Vec3& eulerAngles);


        //@―---------------------------------------------------------------------------
        //! @brief      回転
        //! 
        //! @details    回転順序はZXYです。
        //! @param x X軸の回転量(Degrees)
        //! @param y Y軸の回転量(Degrees)
        //! @param z Z軸の回転量(Degrees)
        //@―---------------------------------------------------------------------------
        Vec3& rotate(f32 x, f32 y, f32 z);


        //@―---------------------------------------------------------------------------
        //! @brief          任意軸回転
        //! 
        //! @param angle    回転量(Degrees)
        //! @param axis     回転軸
        //@―---------------------------------------------------------------------------
        Vec3& rotate(f32 angle, const Vec3& axis);


        //@―---------------------------------------------------------------------------
        //! @brief      X軸回転(Degrees)
        //@―---------------------------------------------------------------------------
        Vec3& rotateX(f32 theta);


        //@―---------------------------------------------------------------------------
        //! @brief      Y軸回転(Degrees)
        //@―---------------------------------------------------------------------------
        Vec3& rotateY(f32 theta);


        //@―---------------------------------------------------------------------------
        //! @brief      Z軸回転(Degrees)
        //@―---------------------------------------------------------------------------
        Vec3& rotateZ(f32 theta);


        //@―---------------------------------------------------------------------------
        //! @brief      拡大
        //@―---------------------------------------------------------------------------
        Vec3& scale(f32 scale) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      拡大
        //@―---------------------------------------------------------------------------
        Vec3& scale(f32 sx, f32 sy, f32 sz) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      拡大
        //@―---------------------------------------------------------------------------
        Vec3& scale(const Vec3& scale) noexcept;


        //===============================================================
        //  判定
        //===============================================================

        //@―---------------------------------------------------------------------------
        //! @brief 単位ベクトルか判定
        //@―---------------------------------------------------------------------------
        bool    isUnit(f32 tolerance = Math::TOLERANCE)const;


        //@―---------------------------------------------------------------------------
        //! @brief 等価判定(許容誤差指定)
        //! 
        //! @param v            比較対象
        //! @param tolerance    許容誤差
        //@―---------------------------------------------------------------------------
        bool    equals(const Vec3& v, f32 tolerance = Math::TOLERANCE)const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief すべての要素が同じ値か判定
        //! 
        //! @param tolerance    許容誤差
        //@―---------------------------------------------------------------------------
        bool    allComponentsEqual(f32 tolerance = Math::TOLERANCE)const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief ゼロベクトルか判定
        //@―---------------------------------------------------------------------------
        bool    isZero(f32 tolerance = Math::TOLERANCE)const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 要素にNaNを含むか判定
        //@―---------------------------------------------------------------------------
        bool    isNaN()const;


        //@―---------------------------------------------------------------------------
        //! @brief 要素にInfを含むか判定
        //@―---------------------------------------------------------------------------
        bool    isInf()const;


        //@―---------------------------------------------------------------------------
        //! @brief 要素にNaNまたはInfを含むか判定
        //@―---------------------------------------------------------------------------
        bool    isNaNOrInf()const;

    public:

        //===============================================================
        //  スタティック関数
        //===============================================================

        //@―---------------------------------------------------------------------------
        //! @brief ベクトルの各要素の絶対値からベクトルを作成
        //@―---------------------------------------------------------------------------
        static Vec3 Abs(const Vec3& v) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 内積
        //@―---------------------------------------------------------------------------
        static f32  Dot(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief 外積
        //@―---------------------------------------------------------------------------
        static Vec3 Cross(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  二つのベクトルの距離を計算
        //@―---------------------------------------------------------------------------
        static f32  Dist(const Vec3& a, const Vec3& b);


        //@―---------------------------------------------------------------------------
        //! @brief  二つのベクトルの距離の二乗を計算
        //@―---------------------------------------------------------------------------
        static f32  SqrDist(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      XY平面上の距離を計算
        //@―---------------------------------------------------------------------------
        static f32  DistXY(const Vec3& a, const Vec3& b);


        //@―---------------------------------------------------------------------------
        //! @brief      XY平面上の距離の二乗を計算
        //@―---------------------------------------------------------------------------
        static f32  SqrDistXY(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      YZ平面上の距離を計算
        //@―---------------------------------------------------------------------------
        static f32  DistYZ(const Vec3& a, const Vec3& b);


        //@―---------------------------------------------------------------------------
        //! @brief      YZ平面上の距離の二乗を計算
        //@―---------------------------------------------------------------------------
        static f32  SqrDistYZ(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      XZ平面上の距離を計算
        //@―---------------------------------------------------------------------------
        static f32  DistXZ(const Vec3& a, const Vec3& b);


        //@―---------------------------------------------------------------------------
        //! @brief      XZ平面上の距離の二乗を計算
        //@―---------------------------------------------------------------------------
        static f32  SqrDistXZ(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      二つのベクトルのマンハッタン距離を計算
        //@―---------------------------------------------------------------------------
        static f32  MDist(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      二つのベクトルの線形補間
        //! 
        //! @param a    開始ベクトル
        //! @param b    終了ベクトル
        //! @param t    補間係数
        //! @return     t=0のときa、t=1の時bを返す。
        //@―---------------------------------------------------------------------------
        static Vec3 Lerp(const Vec3& a, const Vec3& b, f32 t) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      二つのベクトルの球面補間
        //! 
        //! @param a    開始ベクトル
        //! @param b    終了ベクトル
        //! @param t    補間係数
        //! @return     t=0のときa、t=1の時bを返す。
        //@―---------------------------------------------------------------------------
        static Vec3 Slerp(const Vec3& a, const Vec3& b, f32 t);


        //@―---------------------------------------------------------------------------
        //! @brief      二つのベクトルの各要素の大きいほうからベクトルを生成
        //@―---------------------------------------------------------------------------
        static Vec3 Max(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      二つのベクトルの各要素の小さいほうからベクトルを生成
        //@―---------------------------------------------------------------------------
        static Vec3 Min(const Vec3& a, const Vec3& b) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief      二つのベクトルのなす角のコサインを取得
        //@―---------------------------------------------------------------------------
        static f32  CosAngle(const Vec3& a, const Vec3& b);


        //@―---------------------------------------------------------------------------
        //! @brief      二つのベクトルのなす角を取得
        //@―---------------------------------------------------------------------------
        static f32  Angle(const Vec3& a, const Vec3& b);


        //@―---------------------------------------------------------------------------
        //! @brief          反射ベクトルの計算
        //! 
        //! @param inDir    入力ベクトル
        //! @param normal   衝突面の法線
        //@―---------------------------------------------------------------------------
        static Vec3 Mirror(const Vec3& inDir, const Vec3& normal) noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief          投影ベクトルの計算
        //! 
        //! @param inDir    入力ベクトル
        //! @param normal   衝突面の法線
        //@―---------------------------------------------------------------------------
        static Vec3 Projection(const Vec3& inDir, const Vec3& normal) noexcept;

    public:

        static const Vec3 up;      //!< ( 0.0f, 1.0f, 0.0f)
        static const Vec3 down;    //!< ( 0.0f,-1.0f, 0.0f)
        static const Vec3 left;    //!< (-1.0f, 0.0f, 0.0f)
        static const Vec3 right;   //!< ( 1.0f, 0.0f, 0.0f)
        static const Vec3 front;   //!< ( 0.0f, 0.0f, 1.0f)
        static const Vec3 back;    //!< ( 0.0f, 0.0f,-1.0f)
        static const Vec3 zero;    //!< ( 0.0f, 0.0f, 0.0f)
        static const Vec3 one;     //!< ( 1.0f, 1.0f, 1.0f)

    public:

        f32 x;    //!< ベクトルのX成分
        f32 y;    //!< ベクトルのY成分
        f32 z;    //!< ベクトルのZ成分

    };






    //===============================================================
    // インライン関数
    //===============================================================
    //! @cond

    //@―---------------------------------------------------------------------------
    //! @brief      デフォルトコンストラクタ(初期化なし)
    //@―---------------------------------------------------------------------------
    inline Vec3::Vec3() noexcept {}


    //@―---------------------------------------------------------------------------
    //! @brief      コンストラクタ(ゼロ初期化)
    //@―---------------------------------------------------------------------------
    inline Vec3::Vec3(EForceInit) noexcept {
        setZero(); Vec3::zero;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      コンストラクタ(1要素指定)
    //@―---------------------------------------------------------------------------
    inline Vec3::Vec3(f32 scaler) noexcept {
        set(scaler, scaler, scaler);
    }


    //@―---------------------------------------------------------------------------
    //! @brief      コンストラクタ(要素を指定して初期化)
    //@―---------------------------------------------------------------------------
    inline Vec3::Vec3(f32 x, f32 y, f32 z) noexcept {
        set(x, y, z);
    }


    //===============================================================
    //  オペレータ
    //===============================================================


    //@―---------------------------------------------------------------------------
    //! @brief      等価演算子 
    //! 
    //! @details    2つのベクトルの差が Math::TOLERANCE より小さい場合、2つのベクトルは等しいと見なされます。
    //@―---------------------------------------------------------------------------
    inline bool Vec3::operator == (const Vec3& v) const noexcept {
        return Math::IsNearEquals(x, v.x) &&
            Math::IsNearEquals(y, v.y) &&
            Math::IsNearEquals(z, v.z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief 否等価演算子
    //! 
    //! @details    2つのベクトルの差が Math::TOLERANCE より大きい場合、2つのベクトルは異なると見なされます。
    //@―---------------------------------------------------------------------------
    inline bool Vec3::operator != (const Vec3& v) const noexcept {
        return !(operator==(v));
    }


    //@―---------------------------------------------------------------------------
    //! @brief 加算演算子
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator + (const Vec3& v) const noexcept {
        return Vec3(*this) += v;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 加算演算子(スカラー)
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator + (f32 scalar) const noexcept {
        return Vec3(*this) += scalar;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 減算演算子
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator - (const Vec3& v) const noexcept {
        return Vec3(*this) -= v;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 減算演算子(スカラー)
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator - (f32 scalar) const noexcept {
        return Vec3(*this) -= scalar;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 乗算演算子
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator * (const Vec3& v) const noexcept {
        return Vec3(*this) *= v;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 乗算演算子(スカラー)
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator * (f32 scalar) const noexcept {
        return Vec3(*this) *= scalar;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 除算演算子
    //! 
    //! @note   0除算は未定義動作です。
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator / (const Vec3& v) const noexcept {
        return Vec3(*this) /= v;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 除算演算子(スカラー)
    //! 
    //! @note   0除算は未定義動作です。
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator / (f32 scalar) const noexcept {
        return Vec3(*this) /= scalar;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 加算代入演算子
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator += (const Vec3& v) noexcept {
        x += v.x;
        y += v.y;
        z += v.z;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 加算代入演算子(スカラー)
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator += (f32 scalar) noexcept {
        x += scalar;
        y += scalar;
        z += scalar;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 減算代入演算子 
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator -= (const Vec3& v) noexcept {
        x -= v.x;
        y -= v.y;
        z -= v.z;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 減算代入演算子(スカラー)
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator -= (f32 scalar) noexcept {
        x -= scalar;
        y -= scalar;
        z -= scalar;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 乗算代入演算子 
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator *= (const Vec3& v) noexcept {
        x *= v.x;
        y *= v.y;
        z *= v.z;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 乗算代入演算子 (スカラー)
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator *= (f32 scalar) noexcept {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 除算代入演算子 
    //! 
    //! @note   0除算は未定義動作です。
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator /= (const Vec3& v) noexcept {
        x /= v.x;
        y /= v.y;
        z /= v.z;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 除算代入演算子(スカラー)
    //! 
    //! @note   0除算は未定義動作です。
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::operator /= (f32 scalar) noexcept {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 単項マイナス演算子
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::operator - () const noexcept {
        return Vec3(-x, -y, -z);
    }


    //===============================================================
    //  セッター
    //===============================================================

    //@―---------------------------------------------------------------------------
    //! @brief 要素を設定
    //@―---------------------------------------------------------------------------
    inline void Vec3::set(f32 x, f32 y, f32 z) noexcept {
        this->x = x;
        this->y = y;
        this->z = z;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素を設定
    //@―---------------------------------------------------------------------------
    inline void Vec3::set(const Vec3& v) noexcept {
        set(v.x, v.y, v.z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素を全て0に設定
    //@―---------------------------------------------------------------------------
    inline void Vec3::setZero() noexcept {
        setAll(0.0f);
    }


    //@―---------------------------------------------------------------------------
    //! @brief 全ての要素を同じ値で設定
    //@―---------------------------------------------------------------------------
    inline void Vec3::setAll(f32 scalar) noexcept {
        set(scalar, scalar, scalar);
    }


    //===============================================================
    //  ゲッター
    //===============================================================

    //@―---------------------------------------------------------------------------
    //! @brief 要素の最大を取得
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::maxComponent() const noexcept {
        return Math::Max(x, y, z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素の絶対値の最大を取得
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::maxAbsComponent() const noexcept {
        return Math::Max(Math::Abs(x), Math::Abs(y), Math::Abs(z));
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素の最小を取得
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::minComponent() const noexcept {
        return Math::Min(x, y, z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素の絶対値の最小を取得
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::minAbsComponent() const noexcept {
        return Math::Min(Math::Abs(x), Math::Abs(y), Math::Abs(z));
    }


    //@―---------------------------------------------------------------------------
    //! @brief ベクトルの長さを取得
    //! 
    //! @details 二つのベクトルの長さを比較する場合はSqrMagのほうが高速です。
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::length() const {
        return Math::Sqrt(sqrLength());
    }


    //@―---------------------------------------------------------------------------
    //! @brief ベクトルの長さの二乗を取得
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::sqrLength() const noexcept {
        return x * x + y * y + z * z;
    }


    //@―---------------------------------------------------------------------------
    //! @brief              単位ベクトルを取得
    //! 
    //! @details            0ベクトルの場合は0ベクトルを返す。
    //! @param tolerance    ゼロベクトル判定の誤差の許容誤差
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::unitVec(f32 tolerance)const {
        Vec3 unitVec = *this;
        unitVec.normalize(tolerance);
        return unitVec;
    }


    //@―---------------------------------------------------------------------------
    //! @brief              単位ベクトルを取得(ゼロチェックなし)
    //! 
    //! @note               0ベクトルの単位ベクトルを取得しようとした場合、
    //!                     0除算が発生して未定義動作になります。
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::getUnitVecUnsafe()const {
        Vec3 unitVec = *this;
        unitVec.normalizeUnsafe();
        return unitVec;
    }


    //@―---------------------------------------------------------------------------
    //! @brief              方向ベクトルとベクトルの長さを取得
    //! 
    //! @details            0ベクトルの場合 outLen には0ベクトルが入ります。
    //! @param[out] outDir  方向ベクトルの出力
    //! @param[out] outLen  ベクトルの大きさ
    //@―---------------------------------------------------------------------------
    inline void Vec3::toDirectionAndLength(Vec3& outDir, f32& outLen)const {
        if (isZero()) {
            outDir.setZero();
            outLen = 0.0f;
            return;
        }
        outLen = length();
        if (outLen < Math::TOLERANCE) {
            outDir = Vec3::zero;
        } else {
            outDir = (*this) / outLen;
        }
    }


    //===========================================================
    //  変換
    //===========================================================

    //@―---------------------------------------------------------------------------
    //! @brief              ベクトルの正規化
    //! 
    //! @details            0ベクトルの場合は何もしない。
    //! @param tolerance    ゼロベクトル判定の誤差の許容誤差
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::normalize(f32 tolerance) {
        f32 f = length();
        // 0ベクトルの場合は何もしない
        if (f <= tolerance)return *this;
        this->operator/=(f);
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief              ベクトルの正規化(ゼロチェックなし)
    //! 
    //! @note               0ベクトルを正規化した場合は未定義動作です。
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::normalizeUnsafe() {
        f32 f = length();
        this->operator/=(f);
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      移動
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::translate(f32 x, f32 y, f32 z) noexcept {
        this->x += x;
        this->y += y;
        this->z += z;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      移動
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::translate(const Vec3& v) noexcept {
        return translate(v.x, v.y, v.z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief      回転
    //! 
    //! @details    回転順序はZXYです。
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::rotate(const Vec3& eulerAngles) {
        rotateZ(eulerAngles.z);
        rotateX(eulerAngles.x);
        rotateY(eulerAngles.y);
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      回転
    //! 
    //! @details    回転順序はZXYです。
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::rotate(f32 x, f32 y, f32 z) {
        rotateZ(z);
        rotateX(x);
        rotateY(y);
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      X軸回転
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::rotateX(f32 theta) {
        const f32 lx = y;
        const f32 ly = z;
        const f32 rad = Math::Degrees(theta);
        f32 sin, cos;
        Math::SinCos(rad, sin, cos);
        y = lx * cos - ly * sin;
        z = lx * sin + ly * cos;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      Y軸回転
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::rotateY(f32 theta) {
        const f32 lx = z;
        const f32 ly = x;
        const f32 rad = Math::Degrees(theta);
        f32 sin, cos;
        Math::SinCos(rad, sin, cos);
        z = lx * cos - ly * sin;
        x = lx * sin + ly * cos;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      Z軸回転
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::rotateZ(f32 theta) {
        const f32 lx = x;
        const f32 ly = y;
        const f32 rad = Math::Degrees(theta);
        f32 sin, cos;
        Math::SinCos(rad, sin, cos);
        x = lx * cos - ly * sin;
        y = lx * sin + ly * cos;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      拡大
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::scale(f32 s) noexcept {
        return scale(s, s, s);
    }


    //@―---------------------------------------------------------------------------
    //! @brief      拡大
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::scale(f32 sx, f32 sy, f32 sz) noexcept {
        x *= sx;
        y *= sy;
        z *= sz;
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      拡大
    //@―---------------------------------------------------------------------------
    inline Vec3& Vec3::scale(const Vec3& s) noexcept {
        return scale(s.x, s.y, s.z);
    }


    //===============================================================
    //  判定
    //===============================================================

    //@―---------------------------------------------------------------------------
    //! @brief 単位ベクトルか判定
    //@―---------------------------------------------------------------------------
    inline bool Vec3::isUnit(f32 tolerance)const {
        const f32 m = length();
        return Math::Abs(m - 1.0f) < tolerance;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 等価判定(許容誤差指定)
    //! 
    //! @param tolerance    許容誤差
    //@―---------------------------------------------------------------------------
    inline bool Vec3::equals(const Vec3& v, f32 tolerance)const noexcept {
        return
            Math::Abs(x - v.x) <= tolerance &&
            Math::Abs(y - v.y) <= tolerance &&
            Math::Abs(z - v.z) <= tolerance;
    }


    //@―---------------------------------------------------------------------------
    //! @brief すべての要素が同じ値か判定
    //! 
    //! @param tolerance    許容誤差
    //@―---------------------------------------------------------------------------
    inline bool Vec3::allComponentsEqual(f32 tolerance)const noexcept {
        if (tolerance < Math::Abs(x - y))return false;
        if (tolerance < Math::Abs(y - z))return false;
        if (tolerance < Math::Abs(z - x))return false;
        return true;
    }


    //@―---------------------------------------------------------------------------
    //! @brief ゼロベクトルか判定
    //@―---------------------------------------------------------------------------
    inline bool Vec3::isZero(f32 tolerance)const noexcept {
        if (tolerance < Math::Abs(x))return false;
        if (tolerance < Math::Abs(y))return false;
        if (tolerance < Math::Abs(z))return false;
        return true;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素にNaNを含むか判定
    //@―---------------------------------------------------------------------------
    inline bool Vec3::isNaN()const {
        if (Math::IsNaN(x))return true;
        if (Math::IsNaN(y))return true;
        if (Math::IsNaN(z))return true;
        return false;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素にInfを含むか判定
    //@―---------------------------------------------------------------------------
    inline bool Vec3::isInf()const {
        if (Math::IsInf(x))return true;
        if (Math::IsInf(y))return true;
        if (Math::IsInf(z))return true;
        return false;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 要素にNaNまたはInfを含むか判定
    //@―---------------------------------------------------------------------------
    inline bool Vec3::isNaNOrInf()const {
        return isNaN() || isInf();
    }


    //===============================================================
    //  スタティック関数
    //===============================================================

    //@―---------------------------------------------------------------------------
    //! @brief ベクトルの各要素の絶対値からベクトルを作成
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Abs(const Vec3& v) noexcept {
        return Vec3(Math::Abs(v.x), Math::Abs(v.y), Math::Abs(v.z));
    }


    //@―---------------------------------------------------------------------------
    //! @brief 内積
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::Dot(const Vec3& a, const Vec3& b) noexcept {
        return a.x * b.x + a.y * b.y + a.z * b.z;
    }


    //@―---------------------------------------------------------------------------
    //! @brief 外積
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Cross(const Vec3& a, const Vec3& b) noexcept {
        return Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  二つのベクトルの距離を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::Dist(const Vec3& a, const Vec3& b) {
        return (b - a).length();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  二つのベクトルの距離の二乗を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::SqrDist(const Vec3& a, const Vec3& b) noexcept {
        return (b - a).sqrLength();
    }


    //@―---------------------------------------------------------------------------
    //! @brief      XY平面上の距離を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::DistXY(const Vec3& a, const Vec3& b) {
        return Math::Sqrt(SqrDistXY(a, b));
    }


    //@―---------------------------------------------------------------------------
    //! @brief      XY平面上の距離の二乗を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::SqrDistXY(const Vec3& a, const Vec3& b) noexcept {
        return Math::Square(a.x - b.x) + Math::Square(a.y - b.y);
    }


    //@―---------------------------------------------------------------------------
    //! @brief      XZ平面上の距離を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::DistXZ(const Vec3& a, const Vec3& b) {
        return Math::Sqrt(SqrDistXZ(a, b));
    }


    //@―---------------------------------------------------------------------------
    //! @brief      XZ平面上の距離の二乗を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::SqrDistXZ(const Vec3& a, const Vec3& b) noexcept {
        return Math::Square(a.x - b.x) + Math::Square(a.z - b.z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief      YZ平面上の距離を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::DistYZ(const Vec3& a, const Vec3& b) {
        return Math::Sqrt(SqrDistYZ(a, b));
    }


    //@―---------------------------------------------------------------------------
    //! @brief      YZ平面上の距離の二乗を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::SqrDistYZ(const Vec3& a, const Vec3& b) noexcept {
        return Math::Square(a.y - b.y) + Math::Square(a.z - b.z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  二つのベクトルのマンハッタン距離を計算
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::MDist(const Vec3& a, const Vec3& b) noexcept {
        return Math::Abs(a.x - b.x) + Math::Abs(a.y - b.y) + Math::Abs(a.z - b.z);
    }


    //@―---------------------------------------------------------------------------
    //! @brief 二つのベクトルの線形補間
    //! 
    //! @param a    開始ベクトル
    //! @param b    終了ベクトル
    //! @param t    補間係数
    //! @return     t=0のときa、t=1の時bを返す。
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Lerp(const Vec3& a, const Vec3& b, f32 t) noexcept {
        return Vec3(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t
        );
    }


    //@―---------------------------------------------------------------------------
    //! @brief 二つのベクトルの球面補間
    //! 
    //! @param a    開始ベクトル
    //! @param b    終了ベクトル
    //! @param t    補間係数
    //! @return     t=0のときa、t=1の時bを返す。
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Slerp(const Vec3& a, const Vec3& b, f32 t) {
        f32 al, bl;
        Vec3 an, bn;
        a.toDirectionAndLength(an, al);
        b.toDirectionAndLength(bn, bl);
        f32 angle = Math::Acos(Dot(an, bn));
        f32 sinTh = Math::Sin(angle);
        f32 ps = Math::Sin(angle * (1.0f - t)) * Math::Lerp(al, bl, t);
        f32 pe = Math::Sin(angle * t) * Math::Lerp(al, bl, t);

        return Vec3(
            an.x * ps + bn.x * pe,
            an.y * ps + bn.y * pe,
            an.z * ps + bn.z * pe
        );
    }


    //@―---------------------------------------------------------------------------
    //! @brief 二つのベクトルの各要素の大きいほうからベクトルを生成
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Max(const Vec3& a, const Vec3& b) noexcept {
        return Vec3(Math::Max(a.x, b.x), Math::Max(a.y, b.y), Math::Max(a.z, b.z));
    }


    //@―---------------------------------------------------------------------------
    //! @brief 二つのベクトルの各要素の小さいほうからベクトルを生成
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Min(const Vec3& a, const Vec3& b) noexcept {
        return Vec3(Math::Min(a.x, b.x), Math::Min(a.y, b.y), Math::Min(a.z, b.z));
    }


    //@―---------------------------------------------------------------------------
    //! @brief 二つのベクトルのなす角のコサインを取得
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::CosAngle(const Vec3& a, const Vec3& b) {
        return Dot(a.unitVec(), b.unitVec());
    }


    //@―---------------------------------------------------------------------------
    //! @brief 二つのベクトルのなす角を取得
    //@―---------------------------------------------------------------------------
    inline f32 Vec3::Angle(const Vec3& a, const Vec3& b) {
        return Math::AcosD(CosAngle(a, b));
    }


    //@―---------------------------------------------------------------------------
    //! @brief      反射ベクトルの計算
    //! 
    //! @param inDir    入力ベクトル
    //! @param normal   衝突面の法線
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Mirror(const Vec3& inDir, const Vec3& normal) noexcept {
        return inDir - 2.0f * Vec3::Dot(inDir, normal) * normal;
    }


    //@―---------------------------------------------------------------------------
    //! @brief      投影ベクトルの計算
    //! 
    //! @param inDir    入力ベクトル
    //! @param normal   衝突面の法線
    //@―---------------------------------------------------------------------------
    inline Vec3 Vec3::Projection(const Vec3& inDir, const Vec3& normal) noexcept {
        return inDir - Vec3::Dot(inDir, normal) * normal;
    }

    //! @endcond
}// namespace ob::core


//===============================================================
// フォーマット
//===============================================================
//! @cond
template <> struct fmt::formatter<ob::core::Vec3, ob::core::Char> {
    template<typename ParseContext>
    constexpr auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
        return ctx.end();
    }

    template<typename FormatContext>
    auto format(ob::core::Vec3 value, FormatContext& ctx) -> decltype(ctx.out()) {
        return format_to(ctx.out(), TC("({},{},{})"), value.x, value.y,value.z);
    }
};
//! @endcond