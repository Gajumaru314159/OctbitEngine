//***********************************************************
//! @file
//! @brief		ビットフラグ
//! @author		Gajumaru
//***********************************************************
#pragma once
#include <Framework/Core/CoreTypes.h>
#include <type_traits>

namespace ob::core {

	//@―---------------------------------------------------------------------------
	//! @brief		enum値をビットフラグとして扱うためのラップクラス
	//! @details	enum型の内部値が1以上TBitsTypeの最大値以下の2のべき乗である必要があります。
	//! @tparam		TEnum ビットフラグに用いるenum型
	//! @tparam		BitType 内部でビットを管理する変数の型
	//@―---------------------------------------------------------------------------
	template<typename TEnum, typename TBitsType = u32>
	class BitFlags {
	public:

		//! @brief bit_flagss<TEnum, TBitsType>
		using this_type = typename BitFlags<TEnum, TBitsType>;

	public:

		//===============================================================
		// コンストラクタ / デストラクタ
		//===============================================================
		BitFlags() :m_bits(0) {}										//!< コンストラクタ
		BitFlags(TEnum bit) :m_bits(static_cast<TBitsType>(bit)) {}	//!< コンストラクタ(初期値指定)
		explicit BitFlags(TBitsType flags) :m_bits(flags) {}			//!< コンストラクタ(初期値指定)
		BitFlags(const this_type& rhs) :m_bits(rhs.m_bits) {}			//!< コピーコンストラクタ


		//===============================================================
		// オペレータ
		//===============================================================

		//@―---------------------------------------------------------------------------
		//! @brief コピー代入演算子
		//@―---------------------------------------------------------------------------
		BitFlags<TEnum>& operator=(const BitFlags<TEnum>& rhs) {
			m_bits = rhs.m_bits;
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief OR代入演算子
		//@―---------------------------------------------------------------------------
		BitFlags<TEnum>& operator|=(const BitFlags<TEnum>& rhs) {
			m_bits |= rhs.m_bits;
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief AND代入演算子
		//@―---------------------------------------------------------------------------
		BitFlags<TEnum>& operator&=(const BitFlags<TEnum>& rhs) {
			m_bits &= rhs.m_bits;
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief XOR代入演算子
		//@―---------------------------------------------------------------------------
		BitFlags<TEnum>& operator^=(const BitFlags<TEnum>& rhs) {
			m_bits ^= rhs.m_bits;
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief ビット反転演算子
		//@―---------------------------------------------------------------------------
		BitFlags<TEnum> operator~() const {
			BitFlags<TEnum> result;
			result.m_bits = (TBitsType)(~m_bits);
			return result;
		}

		//@―---------------------------------------------------------------------------
		//! @brief OR結合演算子
		//@―---------------------------------------------------------------------------
		BitFlags<TEnum>& operator|(TEnum value) {
			m_bits |= static_cast<TBitsType>(value);
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief			指定されたフラグが設定されているか確認する
		//! 
		//! @param value	確認するフラグ
		//@―---------------------------------------------------------------------------
		bool operator[](TEnum value)const {
			return (m_bits & static_cast<TBitsType>(value));
		}

		//@―---------------------------------------------------------------------------
		//! @brief TBitsType変換演算子 
		//@―---------------------------------------------------------------------------
		explicit operator TBitsType() const {
			return m_bits;
		}

		//@―---------------------------------------------------------------------------
		//! @brief		フラグを保持していないことを確認する
		//@―---------------------------------------------------------------------------
		bool operator!() const {
			return !m_bits;
		}

		//@―---------------------------------------------------------------------------
		//! @brief	いずれかのフラグを保持しているかを確認する
		//@―---------------------------------------------------------------------------
		explicit operator bool() const {
			return !!m_bits;
		}

		//@―---------------------------------------------------------------------------
		//! @brief			指定されたフラグが設定されているか確認する
		//! 
		//! @param value	確認するフラグ
		//@―---------------------------------------------------------------------------
		bool has(this_type& value)const {
			return (m_bits & value.m_bits) == value.m_bits;
		}

		//@―---------------------------------------------------------------------------
		//! @brief			指定されたフラグが設定されているか確認する
		//! 
		//! @param value	確認するフラグ
		//@―---------------------------------------------------------------------------
		bool has(TEnum value)const {
			return (m_bits & static_cast<TBitsType>(value));
		}

		//@―---------------------------------------------------------------------------
		//! @brief			指定されたフラグを1に設定する
		//! 
		//! @param value	指定するフラグ
		//@―---------------------------------------------------------------------------
		this_type& on(TEnum value) {
			m_bits |= static_cast<TBitsType>(value);
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief			指定されたフラグを0に設定する
		//! @param value	指定するフラグ
		//@―---------------------------------------------------------------------------
		this_type& off(TEnum value) {
			m_bits &= ~static_cast<TBitsType>(value);
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief			指定されたフラグを0または1に設定する
		//! 
		//! @param value	指定するフラグ
		//! @param bit		設定するビット値
		//@―---------------------------------------------------------------------------
		this_type& set(TEnum value, bool bit) {
			if (bit)on(value);
			else	off(value);
			return *this;
		}

		//@―---------------------------------------------------------------------------
		//! @brief			クリア
		//@―---------------------------------------------------------------------------
		void clear() {
			m_bits = 0;
		}

		//@―---------------------------------------------------------------------------
		//! @brief			内部値をenum値として取得する
		//! @details		複数のフラグが設定されている場合は未定義。
		//! @return			enum値
		//@―---------------------------------------------------------------------------
		TEnum get_enum()const {
			return static_cast<TEnum>(m_bits);
		}

	private:

		TBitsType m_bits;	//!< 内部データ

	};


	//@―---------------------------------------------------------------------------
	//! @brief OR結合演算子
	//@―---------------------------------------------------------------------------
	template<typename TEnum>
	auto operator|(TEnum left, TEnum right) -> std::enable_if_t<std::is_enum_v<TEnum>, BitFlags<TEnum>> {
		return BitFlags<TEnum>(left) | right;
	}

}// namespace ob::core