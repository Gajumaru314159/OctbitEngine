//***********************************************************
//! @file
//! @brief		参照カウント式スマートポインタ
//! @author		Gajumaru
//***********************************************************
#pragma once
#include "IRefObject.h"


namespace ob {

    //@―---------------------------------------------------------------------------
    //! @brief  参照カウント式スマートポインタ
    //@―---------------------------------------------------------------------------
    template<class T>
    class Ref {
        template<class T, class... TArgs>
        friend Ref<T> MakeRef(TArgs&&... args);

        static_assert(is_base_of_v<IRefObject, T>, "T must inherit IRefObject");
    public:

        //@―---------------------------------------------------------------------------
        //! @brief  コンストラクタ
        //@―---------------------------------------------------------------------------
        constexpr Ref()noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  コンストラクタ(参照なし)
        //@―---------------------------------------------------------------------------
        constexpr Ref(std::nullptr_t)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  コンストラクタ(生ポインタ指定)
        //@―---------------------------------------------------------------------------
        Ref(T* ptr);


        //@―---------------------------------------------------------------------------
        //! @brief  コピーコンストラクタ
        //@―---------------------------------------------------------------------------
        Ref(const Ref& ref)noexcept;

        //@―---------------------------------------------------------------------------
        //! @brief  コピーコンストラクタ
        //! 
        //! @details 継承関係にあるオブジェクトのコピーに使用される。
        //@―---------------------------------------------------------------------------
        template<class U>
        Ref(const Ref<U>& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブコンストラクタ
        //@―---------------------------------------------------------------------------
        Ref(Ref&& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブコンストラクタ
        //! 
        //! @details 継承関係にあるオブジェクトのムーブに使用される。
        //@―---------------------------------------------------------------------------
        template<class U>
        Ref(Ref<U>&& ref)noexcept;

        //@―---------------------------------------------------------------------------
        //! @brief  デストラクタ
        //@―---------------------------------------------------------------------------
        ~Ref();


        //@―---------------------------------------------------------------------------
        //! @brief  コピー代入演算子
        //@―---------------------------------------------------------------------------
        Ref& operator=(const Ref& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  コピー代入演算子
        //! 
        //! @details 継承関係にあるオブジェクトのコピーに使用される。
        //@―---------------------------------------------------------------------------
        template<class U, enable_if_t<is_base_of_v<T, U>>>
        Ref& operator=(const Ref<U>& ref)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブ代入演算子
        //@―---------------------------------------------------------------------------
        Ref& operator=(Ref&& f)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  ムーブ代入演算子
        //! 
        //! @details 継承関係にあるオブジェクトのムーブに使用される。
        //@―---------------------------------------------------------------------------
        template<class U, enable_if_t<is_base_of_v<T, U>>>
        Ref& operator=(Ref<U>&& f)noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  インスタンス参照
        //@―---------------------------------------------------------------------------
        T& operator*() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  メンバアクセス
        //@―---------------------------------------------------------------------------
        T* operator->() const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  参照先が有効か
        //! 
        //! @retval true    有効
        //! @retval false   無効
        //@―---------------------------------------------------------------------------
        explicit operator bool()const noexcept;


        //@―---------------------------------------------------------------------------
        //! @brief  インスタンスキャスト
        //@―---------------------------------------------------------------------------
        operator T* () const;


        //@―---------------------------------------------------------------------------
        //! @brief  新しいオブジェクトの所有権を設定する
        //! 
        //! @details    既に保持しているオブジェクトの参照を放棄した後、新しオブジェクト
        //!             を保持する。
        //! @param ptr  新しく保持するオブジェクトのポインタ
        //@―---------------------------------------------------------------------------
        void Reset(T* ptr);


        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトの参照を放棄する
        //@―---------------------------------------------------------------------------
        void Reset();


        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトのポインタを取得する
        //@―---------------------------------------------------------------------------
        T* Get()const;


    private:

        //@―---------------------------------------------------------------------------
        //! @brief  コンストラクタ(生ポインタ指定)
        //@―---------------------------------------------------------------------------
        Ref(T* ptr,bool isDestructable);


        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトの参照を追加する
        //@―---------------------------------------------------------------------------
        void SafeRetain();


        //@―---------------------------------------------------------------------------
        //! @brief  保持しているオブジェクトの参照を放棄する
        //@―---------------------------------------------------------------------------
        void SafeRelease();

       
    private:

        IRefObject* m_ptr;

        template<class U>
        friend class Ref;

    };


    //@―---------------------------------------------------------------------------
    //! @brief  Ref の構築
    //! 
    //! @details    型 T のコンストラクタに args を渡して新しい Ref を構築します。
    //! @param args コンストラクタに渡す引数
    //@―---------------------------------------------------------------------------
    template<class T, class... TArgs>
    inline Ref<T> MakeRef(TArgs&&... args) {
        return Ref<T>(new T(std::forward<TArgs>(args)...),true);
    }







    //===============================================================
    // 比較演算子
    //===============================================================

    //@―---------------------------------------------------------------------------
    //! @brief  等価演算子
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator==(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.Get() == rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator==(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.Get() == nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator==(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr == rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  否等価演算子
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator!=(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.Get() != rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  否等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator!=(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.Get() != nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  否等価演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator!=(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr != rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator<(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.Get() < rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return std::less<RefObject*>()(lhs.Get(), nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return std::less<T*>()(nullptr, rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<=
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator<=(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.Get() <= rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<=(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.Get() <= nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子<=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator<=(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr <= rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator>(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.Get() > rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.Get() > nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr > rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>=
    //@―---------------------------------------------------------------------------
    template<class T, class U>
    inline bool operator>=(const Ref<T>& lhs, const Ref<U>& rhs) noexcept {
        return (lhs.Get() >= rhs.Get());
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>=(const Ref<T>& lhs, std::nullptr_t) noexcept {
        return (lhs.Get() >= nullptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  比較演算子>=
    //@―---------------------------------------------------------------------------
    template<class T>
    inline bool operator>=(std::nullptr_t, const Ref<T>& rhs) noexcept {
        return (nullptr >= rhs.Get());
    }





    //===============================================================
    // インライン関数
    //===============================================================
    //! @cond


    //@―---------------------------------------------------------------------------
    //! @brief  コンストラクタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline constexpr Ref<T>::Ref()noexcept
        :m_ptr(nullptr){

    }


    //@―---------------------------------------------------------------------------
    //! @brief  コンストラクタ(参照なし)
    //@―---------------------------------------------------------------------------
    template<class T>
    inline constexpr Ref<T>::Ref(std::nullptr_t)noexcept
        :m_ptr(nullptr) {

    }


    //@―---------------------------------------------------------------------------
    //! @brief  コンストラクタ(生ポインタ指定)
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::Ref(T* ptr)
        :m_ptr(ptr) {
        SafeRetain();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  コピーコンストラクタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::Ref(const Ref& ref)noexcept {
        m_ptr = ref.m_ptr;
        SafeRetain();
    }

    //@―---------------------------------------------------------------------------
    //! @brief  コピーコンストラクタ
    //! 
    //! @details 継承関係にあるオブジェクトのコピーに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U>
    inline Ref<T>::Ref(const Ref<U>& ref)noexcept {
        static_assert(is_base_of_v<T, U>, "U must inherit T.");
        m_ptr = ref.m_ptr;
        SafeRetain();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブコンストラクタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::Ref(Ref&& ref)noexcept {
        m_ptr = ref.m_ptr;
        ref.m_ptr = nullptr;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブコンストラクタ
    //! 
    //! @details 継承関係にあるオブジェクトのムーブに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U>
    inline Ref<T>::Ref(Ref<U>&& ref)noexcept {
        static_assert(is_base_of_v<T, U>, "U must inherit T.");
        m_ptr = ref.m_ptr;
        ref.m_ptr = nullptr;
    }

    //@―---------------------------------------------------------------------------
    //! @brief  デストラクタ
    template<class T>
    //@―---------------------------------------------------------------------------
    inline Ref<T>::~Ref() {
        SafeRelease();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  コピー代入演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>& Ref<T>::operator=(const Ref& ref)noexcept {
        if (m_ptr != ref.m_ptr) {
            if (ref.m_ptr) {
                ref.m_ptr->Retain();
            }
            if (m_ptr) {
                m_ptr->Release();
            }
            m_ptr = ref.m_ptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  コピー代入演算子
    //! 
    //! @details 継承関係にあるオブジェクトのコピーに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U, typename enable_if_t<is_base_of_v<T, U>>>
    inline Ref<T>& Ref<T>::operator=(const Ref<U>& ref)noexcept {
        if (m_ptr != ref.m_ptr) {
            if (ref.m_ptr) {
                ref.m_ptr->Retain();
            }
            if (m_ptr) {
                m_ptr->Release();
            }
            m_ptr = ref.m_ptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブ代入演算子
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>& Ref<T>::operator=(Ref&& f)noexcept {
        if (&f != this) {
            SafeRelease();
            m_ptr = f.m_ptr;
            f.m_ptr = nullptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  ムーブ代入演算子
    //! 
    //! @details 継承関係にあるオブジェクトのムーブに使用される。
    //@―---------------------------------------------------------------------------
    template<class T>
    template<class U, typename enable_if_t<is_base_of_v<T, U>>>
    inline Ref<T>& Ref<T>::operator=(Ref<U>&& f)noexcept {
        if (&f != this) {
            SafeRelease();
            m_ptr = f.m_ptr;
            f.m_ptr = nullptr;
        }
        return *this;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  インスタンス参照
    //@―---------------------------------------------------------------------------
    template<class T>
    inline T& Ref<T>::operator*() const noexcept {
        assert(m_ptr!=nullptr);
        return *static_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  メンバアクセス
    //@―---------------------------------------------------------------------------
    template<class T>
    inline T* Ref<T>::operator->() const noexcept {
        assert(m_ptr != nullptr);
        return static_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  参照先が有効か
    //! 
    //! @retval true    有効
    //! @retval false   無効
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::operator bool()const noexcept {
        return m_ptr != nullptr;
    }


    //@―---------------------------------------------------------------------------
    //! @brief  インスタンスキャスト
    //@―---------------------------------------------------------------------------
    template<class T>
    inline Ref<T>::operator T* () const {
        return static_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  新しいオブジェクトの所有権を設定する
    //! 
    //! @details    既に保持しているオブジェクトの参照を放棄した後、新しオブジェクト
    //!             を保持する。
    //! @param ptr  新しく保持するオブジェクトのポインタ
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::Reset(T* ptr) {
        if (ptr != m_ptr) {
            SafeRelease();
            m_ptr = ptr;
            SafeRetain();
        }
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトの参照を放棄する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::Reset() {
        SafeRelease();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトのポインタを取得する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline T* Ref<T>::Get()const {
        return reinterpret_cast<T*>(m_ptr);
    }


    //@―---------------------------------------------------------------------------
    //! @brief  コンストラクタ(生ポインタ指定)
    //@―---------------------------------------------------------------------------
    template<class T>
    Ref<T>::Ref(T* ptr, bool isDestructable):Ref(ptr) {
        if(LIKELY(isDestructable))m_ptr->EnableDestruct();
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトの参照を追加する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::SafeRetain() {
        if (m_ptr) {
            m_ptr->Retain();
        }
    }


    //@―---------------------------------------------------------------------------
    //! @brief  保持しているオブジェクトの参照を放棄する
    //@―---------------------------------------------------------------------------
    template<class T>
    inline void Ref<T>::SafeRelease() {
        if (m_ptr) {
            m_ptr->Release();
            m_ptr = nullptr;
        }
    }


    //! @endcond
}// namespcae ob